(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{701:function(t,v,e){"use strict";e.r(v);var _=e(125),a=Object(_.a)({},(function(){var t=this,v=t.$createElement,e=t._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"集合概要"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#集合概要"}},[t._v("#")]),t._v(" 集合概要")]),t._v(" "),e("p",[t._v("Java的"),e("code",[t._v("java.util")]),t._v("包主要提供了以下三种类型的集合（也可以叫作容器，用来存储对象）")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("List")]),t._v("：一种有序列表的集合")]),t._v(" "),e("li",[e("code",[t._v("Set")]),t._v("：一种保证没有重复元素的集合")]),t._v(" "),e("li",[e("code",[t._v("Map")]),t._v("：一种通过键值（key-value）查找的映射表集合")])]),t._v(" "),e("p",[t._v("Java集合的设计有几个特点：")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("一是实现了接口和实现类相分离，例如，有序表的接口是"),e("code",[t._v("List")]),t._v("，具体的实现类有"),e("code",[t._v("ArrayList")]),t._v("，"),e("code",[t._v("LinkedList")]),t._v("等，")])]),t._v(" "),e("li",[e("p",[t._v("二是支持泛型，我们可以限制在一个集合中只能放入同一种数据类型的元素，如：")]),t._v(" "),e("div",{staticClass:"language-java extra-class"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("List")]),e("span",{pre:!0,attrs:{class:"token generics"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" list "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ArrayList")]),e("span",{pre:!0,attrs:{class:"token generics"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 只能放入String类型")]),t._v("\n")])])])]),t._v(" "),e("li",[e("p",[t._v("三是Java访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储")])])]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),e("p",[t._v("由于Java的集合设计非常久远，中间经历过大规模改进，我们要注意到有一小部分集合类是遗留类，不应该继续使用：")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("Hashtable")]),t._v("：一种线程安全的"),e("code",[t._v("Map")]),t._v("实现；")]),t._v(" "),e("li",[e("code",[t._v("Vector")]),t._v("：一种线程安全的"),e("code",[t._v("List")]),t._v("实现；")]),t._v(" "),e("li",[e("code",[t._v("Stack")]),t._v("：基于"),e("code",[t._v("Vector")]),t._v("实现的"),e("code",[t._v("LIFO")]),t._v("的栈。")])]),t._v(" "),e("p",[t._v("还有一小部分接口是遗留接口，也不应该继续使用：")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("Enumeration<E>")]),t._v("：已被"),e("code",[t._v("Iterator<E>")]),t._v("取代。")])])]),t._v(" "),e("h2",{attrs:{id:"泛型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#泛型"}},[t._v("#")]),t._v(" 泛型")]),t._v(" "),e("p",[t._v("泛型是JDK1.5以后增加的，它可以帮助我们建立类型安全的集合。在使用了泛型的集合中，遍历时不必进行强制类型转换。JDK提供了支持泛型的编译器，将运行时的类型检查提前到了编译时执行，提高了代码可读性和安全性。")]),t._v(" "),e("p",[t._v("泛型的本质就是“数据类型的参数化”。 我们可以把“泛型”理解为数据类型的一个占位符(形式参数)，即告诉编译器，在调用泛型时必须传入实际类型。")]),t._v(" "),e("p",[t._v("为了能够更好的学习集合，建议先学习"),e("strong",[t._v("泛型")]),t._v("。")]),t._v(" "),e("ul",[e("li",[e("RouterLink",{attrs:{to:"/posts/generics.html"}},[t._v("Java泛型学习笔记")])],1),t._v(" "),e("li",[e("a",{attrs:{href:"https://www.w3cschool.cn/java/java-generics.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("w3cschool教程")])])]),t._v(" "),e("h2",{attrs:{id:"collection接口"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#collection接口"}},[t._v("#")]),t._v(" Collection接口")]),t._v(" "),e("p",[t._v("Collection 表示一组对象，它是集中、收集的意思。Collection接口是List、Set接口的父接口，也就是List、Set都包含Collection中的方法，可以在List、Set接口的实现类中进行测试。")]),t._v(" "),e("p",[t._v("Collection的功能:")]),t._v(" "),e("p",[t._v("1、添加功能")]),t._v(" "),e("p",[e("code",[t._v("boolean add (objcet obj)")]),t._v(":添加一个元素")]),t._v(" "),e("p",[e("code",[t._v("boolean addAll(Collection c)")]),t._v(":添加一个集合的元素")]),t._v(" "),e("p",[t._v("2、删除功能:")]),t._v(" "),e("p",[e("code",[t._v("void clear ()")]),t._v(":清除所有的元素")]),t._v(" "),e("p",[e("code",[t._v("boolean remove (object)")]),t._v(":移除一个元素")]),t._v(" "),e("p",[e("code",[t._v("boolean removeAll(Collection c)")]),t._v(":移除本集合和集合c中都包含的元素")]),t._v(" "),e("p",[t._v("3、判断功能:")]),t._v(" "),e("p",[e("code",[t._v("boolean contains (0bject o)")]),t._v(":判断集合是否包含该元素")]),t._v(" "),e("p",[e("code",[t._v("boolean containsAll(Collection c)")]),t._v(":判断集合中是否包含指定的集合元素，只有包含所有的元素,才叫包含")]),t._v(" "),e("p",[e("code",[t._v("boolean isEmpty()")]),t._v(":判断集合是否为空")]),t._v(" "),e("p",[t._v("4、获取功能:")]),t._v(" "),e("p",[e("code",[t._v("Iterator<E>iterator()")]),t._v(":迭代器")]),t._v(" "),e("p",[e("code",[t._v("Object[] toArray()")]),t._v(":转化成Object数组")]),t._v(" "),e("p",[t._v("5、长度功能:")]),t._v(" "),e("p",[e("code",[t._v("int size()")]),t._v(":元素的个数")]),t._v(" "),e("p",[t._v("6、交集功能:")]),t._v(" "),e("p",[e("code",[t._v("boolean retainAll(Collection c)")]),t._v(":取本集合和集合c都包含的元素")]),t._v(" "),e("p",[t._v("Collection 类图（工作中需要掌握一些常用的集合类就行了）")]),t._v(" "),e("h2",{attrs:{id:"list接口及其实现类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#list接口及其实现类"}},[t._v("#")]),t._v(" List接口及其实现类")]),t._v(" "),e("p",[t._v("List是有序、可重复的容器。")]),t._v(" "),e("p",[e("strong",[t._v("有序")]),t._v("：List中每个元素都有索引标记。可以根据元素的索引标记(在List中的位置)访问元素，从而精确控制这些元素。")]),t._v(" "),e("p",[e("strong",[t._v("可重复")]),t._v("：List允许加入重复的元素。更确切地讲，List通常允许满足 e1.equals(e2) 的元素重复加入容器。")]),t._v(" "),e("p",[t._v("除了Collection接口中的方法，List多了一些跟顺序(索引)有关的方法")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("方法")]),t._v(" "),e("th",[t._v("说明")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("void add (int index, Object element)")]),t._v(" "),e("td",[t._v("在指定位置插入元素，以前元素全部后移一位")])]),t._v(" "),e("tr",[e("td",[t._v("Object set (int index,Object element)")]),t._v(" "),e("td",[t._v("修改指定位置的元素")])]),t._v(" "),e("tr",[e("td",[t._v("Object get (int index)")]),t._v(" "),e("td",[t._v("返回指定位置的元素")])]),t._v(" "),e("tr",[e("td",[t._v("Object remove (int index)")]),t._v(" "),e("td",[t._v("删除指定位置的元素，后面元素全部前移一位")])]),t._v(" "),e("tr",[e("td",[t._v("int indexOf (Object o)")]),t._v(" "),e("td",[t._v("返回第一个匹配元素的索引，如果没有该元素，返回-1.")])]),t._v(" "),e("tr",[e("td",[t._v("int lastIndexOf (Object o)")]),t._v(" "),e("td",[t._v("返回最后一个匹配元素的索引，如果没有该元素，返回-1")])])])])])}),[],!1,null,null,null);v.default=a.exports}}]);